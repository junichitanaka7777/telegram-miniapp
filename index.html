<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Telegram Mini Game — Minimal</title>
  <style>
    :root{
      --bg:#0e0f12; --fg:#ffffff; --muted:#9aa0a6; --accent:#5b86ff;
      --card:#151720; --ok:#10b981; --warn:#f59e0b;
    }
    html,body{height:100%;margin:0}
    body{background:var(--bg);color:var(--fg);font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif;}
    .wrap{display:flex;flex-direction:column;align-items:center;justify-content:center;height:100%;gap:16px;padding:16px}
    .card{background:var(--card);border-radius:16px;box-shadow:0 10px 30px rgba(0,0,0,.25);padding:16px;width:min(480px,92vw)}
    h1,h2,p{margin:0 0 8px}
    canvas{width:100%;height:auto;background:#0b0d14;border-radius:12px;display:block}
    .row{display:flex;align-items:center;justify-content:space-between;gap:12px;margin-top:8px}
    .btn{appearance:none;border:0;border-radius:12px;padding:12px 16px;font-weight:600;background:var(--accent);color:white;cursor:pointer}
    .muted{color:var(--muted)}
  </style>
</head>
<body>
  <div class="wrap">
    <div class="card">
      <h1>Mini Game</h1>
      <p class="muted">Tap the moving target. Score as much as you can in 30 seconds.</p>
      <p id="hello" class="muted">Loading user…</p>
      <canvas id="game" width="360" height="540"></canvas>
      <div class="row">
        <div>⏱️ <span id="time">30.0</span>s • ⭐ <strong id="score">0</strong></div>
        <button id="restart" class="btn">Restart</button>
      </div>
    </div>
  </div>

  <script>
    // --- Telegram WebApp bootstrap ---
    const tg = window.Telegram && window.Telegram.WebApp ? window.Telegram.WebApp : null;
    if (tg){
      tg.ready();
      // Expand to full height if possible
      try { tg.expand(); } catch(_){}

      // Apply Telegram theme to CSS variables (light/dark/brand)
      const th = tg.themeParams || {};
      const css = {
        '--bg': th.bg_color,
        '--fg': th.text_color,
        '--muted': th.hint_color,
        '--card': th.secondary_bg_color,
        '--accent': th.button_color
      };
      for (const k in css){ if(css[k]) document.documentElement.style.setProperty(k, css[k]); }

      // Greet user
      const u = tg.initDataUnsafe && tg.initDataUnsafe.user;
      if (u){
        document.getElementById('hello').textContent = `Hello, ${u.first_name}!`;
      } else {
        document.getElementById('hello').textContent = 'Hello! (no user)';
      }

      // MainButton = Share / Close
      tg.MainButton.setText('Close');
      tg.MainButton.onClick(() => tg.close());
      tg.MainButton.show();
    }

    // --- Minimal game loop (target tapper) ---
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');

    let score = 0; let timeLeft = 30.0; let playing = true;
    const hudScore = document.getElementById('score');
    const hudTime = document.getElementById('time');

    const target = { x: 180, y: 270, r: 28, vx: 110, vy: 130 };

    function restart(){
      score = 0; timeLeft = 30.0; playing = true;
      target.x = canvas.width/2; target.y = canvas.height/2;
      target.vx = 110; target.vy = 130;
      hudScore.textContent = score;
      hudTime.textContent = timeLeft.toFixed(1);
    }

    document.getElementById('restart').onclick = restart;

    function update(dt){
      if (!playing) return;
      timeLeft -= dt;
      if (timeLeft <= 0){ timeLeft = 0; playing = false; endGame(); }
      hudTime.textContent = timeLeft.toFixed(1);

      // move
      target.x += target.vx * dt;
      target.y += target.vy * dt;
      // bounce
      if (target.x - target.r < 0 && target.vx < 0) target.vx *= -1;
      if (target.x + target.r > canvas.width && target.vx > 0) target.vx *= -1;
      if (target.y - target.r < 0 && target.vy < 0) target.vy *= -1;
      if (target.y + target.r > canvas.height && target.vy > 0) target.vy *= -1;
    }

    function draw(){
      // background
      ctx.clearRect(0,0,canvas.width,canvas.height);
      // target
      ctx.beginPath();
      ctx.arc(target.x, target.y, target.r, 0, Math.PI*2);
      ctx.fillStyle = 'rgba(255,255,255,0.95)';
      ctx.fill();
      // ring
      ctx.lineWidth = 4;
      ctx.strokeStyle = 'rgba(91,134,255,0.9)';
      ctx.stroke();
    }

    let last=0; function loop(ts){
      const dt = Math.min(0.05, (ts - last)/1000 || 0);
      last = ts;
      update(dt); draw();
      requestAnimationFrame(loop);
    }
    requestAnimationFrame(loop);

    canvas.addEventListener('click', (e)=>{
      if (!playing) return;
      const rect = canvas.getBoundingClientRect();
      const cx = (e.clientX - rect.left) * (canvas.width / rect.width);
      const cy = (e.clientY - rect.top) * (canvas.height / rect.height);
      const dx = cx - target.x, dy = cy - target.y;
      if (dx*dx + dy*dy <= target.r*target.r){
        score++;
        hudScore.textContent = score;
        // make it harder
        target.vx *= 1.05; target.vy *= 1.05; target.r = Math.max(16, target.r * 0.98);
        // haptic (if available)
        try{ tg && tg.HapticFeedback?.impactOccurred('light'); }catch(_){ }
      }
    });

    function endGame(){
      // Simple end state: show alert with score
      if (tg && tg.showAlert){
        tg.showAlert(`Time! Your score: ${score}`);
      } else {
        alert(`Time! Your score: ${score}`);
      }
    }

    // Auto-restart if opened from Telegram back stack
    document.addEventListener('visibilitychange', ()=>{
      if (!document.hidden && !playing && timeLeft===0){ restart(); }
    });

  </script>
</body>
</html>